clear all
close all
clc
% This code serves as proof to the fact that in our case using the integral
% as a piece-wise function and computing the integral for each function
% doesn't change the final result with respect to what we used in our
% report
mkt = import_data(0);
sizes = [8,8,21];
sz1 = sizes(1); sz2 = sizes(2); szb = sizes(3);

% interpolating to find discounts for the needed dates 
mkt.DF = interpol(mkt.t0,mkt.dates, mkt.OIS,mkt.datesExpiry);

l = length(mkt.strikes); tn = length(mkt.tenors); s = l*tn; 

mkt_vols = mkt.volatilitySurface';
volatility_vector = mkt_vols(:);
strikes = mkt.strikes;

tau_2 = mkt.datesExpiry./252; % divided by 252 so that we work with years
tau_1 = mkt.t0/252;
%%
fwd = mkt.fwd;
DF = mkt.DF; 
r = -log(DF)./yearfrac(mkt.t0, tau_2*252);  % zero rate
%%
a = 0.4; b = 0.4; c = 1; 
initial = [a, b, c];

% setting lower and upper bounds for sigmas and beta
lbs = eps; lbb = -100; ubs = 4; ubb = 100; 
bounds = [lbs, lbb, ubs, ubb];
%% Initial parameters
% lower and upper bounds and starting points for the optimization
LB = cat(1, bounds(1)*ones(sz1+sz2,1), bounds(2)*ones(szb,1));
x0 = cat(1, initial(1)*ones(sz1,1), initial(2)*ones(sz2,1), initial(3)*ones(szb,1));
UB = cat(1, bounds(3)*ones(sz1+sz2,1), bounds(4)*ones(szb,1));

%% Calibration

% we define the 2 following functions to make sure that arrayfun used below 
% will depend only on one iteration variable (i) 

iter = @(i, sz) round((i-1)/(s/sz) + 0.5); 
    

repeat = @(i, sz) (rem(i, sz)~=0)*rem(i, sz)+(rem(i, sz)==0)*sz;


opts = optimset('display','off'); % used to hide output of the lsqnonlin


% optimization by solving a non linear LS problem, minimizing the
% difference between the market price (computed using blk formula) and the
% model price (obtained with the "swaption_price_2p" function)
PARAMS = ...
    lsqnonlin(@(p) ...
        abs(arrayfun(@(i) ...
        blkprice(...
            fwd, ...
            strikes(repeat(i,l)), ...
            r(iter(i,tn)), ...
            (tau_2(iter(i,tn)) - tau_1), ...
            volatility_vector(i)) ...
        - swaption_price_3p(...
            tau_1, ...
            tau_2(iter(i,tn)), ...
            strikes(repeat(i,l)), ...
            fwd, ...
            r(iter(i,tn)), ...
            p(1:iter(i,sz1)), ...
            p(sz1+1:iter(i,sz2)+sz1), ...
            p(repeat(i,szb)+sz1+sz2), mkt.tenors, iter(i,sz1)), ...
        [1:s]')), ...
        x0, LB, UB, opts);


%% Compute the calibrated model's prices and the error
% Now we find the model prices using the parameters just calibrated
model_prices = arrayfun(@(i)...
    swaption_price_3p(...
        tau_1,...
        tau_2(iter(i,tn)),...
        strikes(repeat(i,l)),...
        fwd,...
        r(iter(i,tn)), ...
        PARAMS(1:iter(i,sz1)), ...
        PARAMS(sz1+1:iter(i,sz2)+sz1), ...
        PARAMS(repeat(i,szb)+sz1+sz2), ...
        mkt.tenors, iter(i,sz1)), ...
        [1:s]');
Model_prices = reshape(model_prices,l,tn);

% computing market prices using black model to get the error
mkt_prices = arrayfun(@(i)...
    blkprice(...
        fwd,...
        strikes(repeat(i,l)),...
        r(iter(i,tn)),...
        (tau_2(iter(i,tn)) - tau_1),...
        volatility_vector(i)), ...
        [1:s]');
Market_prices = reshape(mkt_prices,l,tn);

% MEAN ABSOLUTE ERROR of the prices
ERROR_PRICES = mean(abs(mkt_prices - model_prices));
